# Linux Iptables Firewall

- [Iptables on CentOS 7](#iptables-on-centos-7)
- [How Linux Firewall Work](#how-linux-firewall-work)
    - [History](#history)
    - [Types of packet-filtering firewalls](#types-of–packet-filtering-firewalls)
    - [General criteria and Actions](#general-criteria–and-actions)
- [How Iptables works](#how-iptables-works)
- [Table Chains](#table-chains)
- [Chain Policy](#chain-policy)
- [Adding iptables Rules](#adding-iptables-rules)
- [Iptables Rules Order](#iptables-rules-order)
- [List iptables Rules](#list-iptables-rules)
- [Deleting Rules](#deleting-rules)
- [Replacing Rules](#replacing-rules)
- Listing Specific Table
- Iptables User Defined Chain
- Redirection to a User Defined Chain
- Setting Default Policy for Chains
- Handling ICMP Traffic
- Blocking Bad Flags
- SYN Flooding
- Drop INVALID State Packets
- Drop Fragmented Packets
- Save iptables Rules

## Iptables on CentOS 7

If you are using CentOS 7, you will find that firewalld was introduced to manage iptables, so if you want to go back to iptables you have to stop and mask firewalld.
```
$ systemctl stop firewalld
$ systemctl mask firewalld
```
---
NOTE
firewalld is a replacement for iptables and improves the management of Linux security by enabling configuration changes without stopping the current connections.
Firewalld runs as a daemon that allows for rules to be added and changed instantly and it uses network zones to define a level of trust for any and all associated network connections.
---

Install iptables service, enable and start it:
```
$ yum install iptables-services
$ systemctl enable iptables
$ systemctl start iptables
```

## How Linux Firewall Works

#### History
Iptables firewall functions are built on the Netfilter framework that exists in the Linux kernel. Netfilter was written by an awesome guy called Rusty Russell.
Netfilter allows Linux to perform packet filtering and shaping at a kernel level.

#### Types of packet-filtering firewalls

- **Stateless** packet filtering firewall examines only the header of a packet for filtering.
It sees each packet in isolation and thus has no way to determine if a packet is part of an existing connection or not.

- **Stateful** firewall keeps information about the status of the connections passing through it.
This allows the firewall to filter on the state of the connection, and this gives more control over the traffic.

#### General criteria and Actions

Netfilter works by referring to a set of tables which contain chains which contain individual rules.
If the current packet being processed satisfies the selection criteria of a rule, then the action specified by that rule is carried out.

Any network connection between two hosts is a combination of:
- a **source IP address** and **port**
- a **destination IP address** and **port**
Iptables can use these values to filter traffic coming in and out of hosts, as well as protocol types.

The actions that can be performed on the package are:
- **ignore**
- **accept**
- **reject**
- pass onto other rules for more processing

## How Iptables Works
### Tables

Netfilter has three built-in tables that can hold rules for processing:
- **the Filter table**, which is the default table used for all rules related to the filtering of your traffic.
- **the Nat table**, which handles NAT rules
- **the Mangle table**, which covers a variety of packet alteration functions

### Table Chains

The iptables rules are broken down into groups called chains. Each table contains default chains that are built into the table.
You can also create your own chains on each table to hold additional rules.

The built-in chains in the filter table are:
- **INPUT** (a packet is coming to the host)
- **OUTPUT** (a packet is generated by the host itself and going out)
- **FORWARD** (a packet that have entered the host but is destined for some other host)


### Chain Policy

Each chain in the filter table has a policy. **A policy is the default action taken**.

The policies you can use for packets are:
- **ACCEPT** (accept the traffic and allows it to pass through the firewall)
- **DROP** (discard a packet without notifying the sender)
- **REJECT** (discard the packet, but it sends an ICMP packet to the sender to tell him about the rejection)
---
From a security perspective, you should deny all traffic by default and open the host to only the traffic to which you have explicitly granted access.
DROP for the INPUT and OUTPUT chains means incoming and outgoing traffic are not allowed unless you explicitly add rules to allow the traffic.
---

### Adding iptables Rules

To add a new rule, you can simply add one to a chain with the iptables command
```
$ iptables -A INPUT -i eth0 -p tcp --dport 80 -d 192.168.1.2 -j ACCEPT
```

- `–A` means we are adding a new rule.
By default, all new rules are added to the filter table unless you specify another table.
- `-i` flag specifies which device the traffic will use to enter the host.
If you do not specify a device then iptables assumes the rule applies to all incoming network traffic from all devices.
- `–p` flag specifies the protocol of the packets you are filtering, which is TCP in our case.
- `–dport` flag tells iptables to select only packets destined for port 80.
- `-d` selects only those packets destined for the specified IP address, 192.168.1.2.
If you do not specify a destination IP address, then iptables would apply this rule to all incoming traffic on eth0 regardless of IP address.
- `-j`, specifies the action or the JUMP action to do, here we are accepting the packets using the accept policy.
The above rule allows incoming HTTP traffic which is on port 80.

We can add another rule to allow HTTPS traffic which is on port 443.
```
$ iptables -A INPUT -i eth0 -p tcp --dport 443 -d 192.168.1.2 -j ACCEPT
```

Easy right? This time the only difference is the destined port, 443.

Now we allow both HTTP and HTTPS, but this is only the incoming traffic, what about allowing outgoing traffic?

```
$ iptables -A OUTPUT -o eth0 -p tcp --sport 80 -j ACCEPT
$ iptables -A OUTPUT -o eth0 -p tcp --sport 443 -j ACCEPT
```

You can replace the numeric port number on sport or dport with the service name like HTTP or HTTPS. These services names are defined in the /etc/services file, which makes reading rules easier.

```
$ iptables -A OUTPUT -o eth0 -p tcp --sport HTTP -j ACCEPT
$ iptables -A OUTPUT -o eth0 -p tcp --sport HTTPS -j ACCEPT
```


### Iptables Rules Order

When you use the `-A` flag to add a rule, it is appended to the end of the current rules in a chain. You can also add rules using the `-I` flag, which adds rules to the top of the chain of current rules.
**The sequence of the rules matters**.
The rules are checked in the order they are added.
With the `-I` flag you can also add a rule into a chain using a line number, so we can specify where exactly our rules placed.
```
$ iptables -I INPUT 1 -i eth0 -p tcp -j ACCEPT
$ iptables -I INPUT 2 -i eth0 -p tcp --dport 80 -j DROP
```

The first rule accepts all TCP traffic comes to eth0, and the number 1 after the chain means you need to insert the rule in the first line of INPUT chain.
The second rule drops the traffic that enters port 80, and the number 2 after the chain means it is the second rule in the INPUT chain.

ATTENTION: The first rule will accept all the traffic then the second rule will be ignored because the first rule already accepts all the traffic so the second rule here makes no sense.

### List iptables Rules

List the rules in a chain
```
$ iptables -L INPUT
```

Show the line numbers for rules
```
$ iptables -L INPUT --line-numbers
```

The list shows the services names, but you can show port numbers instead using `–n` option:
```
$ iptables -L INPUT -n --line-numbers
```

This makes the listing faster as it stops iptables that are waiting for DNS resolution and service lookups.
List all rules for all chains like this
```
$ iptables -L -n --line-numbers
```

Using `-v` flag you can see the associated counter that tracks how many bytes and packets have been processed by that rule
```
$ iptables -L -v
```

Also, you can reset the counters to zero using `-Z` flag.


### Deleting Rules

Delete a rule
```
$ iptables -D INPUT -i eth0 -p tcp --dport https -d 192.168.1.2 -j ACCEPT
```

**NB You must match the exact specifications of the rule to be deleted otherwise the deletion will fail**.

You can delete the rule using the order number instead of writing the rule specifications.
```
$ iptables -D INPUT 2
```

You can delete all rules in a specific chain using the -F flag, which means flush all rules.
```
$ iptables -F INPUT
```

**ATTENTION: If you forget to mention the chain name when using the -F flag then all rules in all chains will be flushed**.

### Replacing Rules

You can replace existing rules with your own rule using the `-R` flag:
```
$ iptables -R INPUT 1 -i eth0 -p tcp --dport https -d 192.168.1.2 -j ACCEPT
```

This command will replace the first rule in the INPUT chain with the typed rule.

### Listing Specific Tables

You can specify the table using the -t flag:
```
$ iptables -L -t nat
```


Iptables User Defined Chain

You can create a new chain using the -N flag:

 $ iptables -N MY_CHAIN

Also, you can rename it using the -E flag:

 $ iptables -E MY_CHAIN NEW_NAME

And you can delete the user-defined chain using the -X flag:

 $ iptables -X MY_CHAIN

If you don’t mention the chain name when using the -X flag it will delete all user-defined chains.

You can’t delete built-in chains like INPUT and OUTPUT.

Redirection to User Defined Chain

You can redirect packets to a user-defined chain like built-in chains using the -j flag.

 $ iptables -A INPUT -p icmp -j MY_CHAIN

So all incoming ICMP traffic will be redirected to the newly created chain called MY_CHAIN.

Setting Default Policy for Chains

You can use the -p flag to set the default policy for a specific chain. The default policy could be ACCEPT, REJECT, and DROP.

 $ iptables -P INPUT DROP

So now the input chain will drop any packet that comes through unless you write a rule to allow any incoming traffic.

Handling ICMP Traffic

ICMP provides error, control, and informational messages such as the messages used by the ping command. This is important for network troubleshooting and diagnostics but the attacker can do some malicious things with it, like:

Sending a huge amount of ICMP packets that leads to consuming the available bandwidth resulting in a Denial of Service.
Sending forged ICMP echo packets to network broadcast addresses. The broadcast addresses reply with ICMP echo reply packets, resulting in a Denial of Service.
Sending an ICMP echo packet larger than the maximum IP packet size that may crash your system.
You can prevent all these attacks using iptables firewall.

A good solution is all incoming ICMP traffic should be dropped except responses to outgoing connections. For example, all incoming ping (echo request) packets are dropped, but incoming ping reply (echo reply) packets that are in reply to pings generated on the local host are accepted.

You want to create some chains to hold the ICMP-related rules.

I will create two chains. The first one I have called is ICMP_IN, which handles the incoming ICMP traffic. The second one I will call is ICMP_OUT, which will handle outgoing ICMP traffic. User-created chains allow you to better structure your rules and allow you to group related rules that handle specific traffic types.

Then we will redirect the traffic to those defined chains:

Now when ICMP traffic is received by the INPUT chain, it is directed to the user-created chain ICMP_IN; and when it is received by the OUTPUT chain, it is handled by the ICMP_OUT chain.

The ICMP Message Types are:

0             Echo Reply

3             Destination Unreachable

4             Source Quench

5             Redirect

8             Echo Request

11           Time Exceeded

12           Parameter Problem

13           Timestamp

14           Timestamp Reply

15           Information Request

16           Information Reply

The iptables rules can target individual ICMP messages types by selecting only ICMP traffic with the -p icmp flag in combination with the –icmp-type flag to select the particular ICMP message type.

 $ iptables -A ICMP_IN -p icmp --icmp-type 8 -j DROP

Here we add our first rule to the ICMP_IN chain which will drop the echo request.

Now we should write rules to allow inbound echo replies, and time exceeded and destination unreachable messages.

Using the -m state allows you to perform state inspection and matching on the incoming packets, which is one of the key features of a stateful packet-filtering in iptables.

There are four states: NEW, ESTABLISHED, RELATED, or INVALID.

The NEW connection state indicates a freshly initiated connection.

The ESTABLISHED connection state indicates an existing connection that is in the process of transferring data.

The RELATED state refers to a connection that is used to facilitate another connection.

The INVALID state refers to a connection that has been seen to have problems in processing packets.

Back to our rules. It does not allow NEW connections using the ICMP to be made. This means attempts to ping this host will result in an error.

Now you add the rules to take care of the outbound ICMP traffic in case you want to ping remote hosts.

 $ iptables -A ICMP_OUT -o eth0 -p icmp --icmp-type 8 -m state --state NEW -j ACCEPT

We are not discussing how to disable ICMP packets here in specific, we are investigating how iptables firewall works. There are a lot of firewalls you can use that build upon iptables, so instead of using a ready-made product without understanding what's going on, you should be able to add your own rules, remove unnecessary ones, or modify existing rules to fit your needs.

Blocking Bad Flags

When a new TCP connection is created, a process that is commonly referred to as the three-way handshake occurs.

You send an SYN TCP packet, then the receiver sends as a response SYN ACK packet back to you, and then you send an ACK to it. This is the complete three-way handshake.

You can use iptables to select packets with particular TCP flags using the –tcp-flags flag.

 $ iptables -A INPUT -p tcp --tcp-flags ALL SYN -j DROP

This rule is telling you to look at all TCP flags (SYN, ACK, FIN, RST, URG, and PSH) and match the packets that have the flag SYN set.

There are some combinations of flags that you want to block with your iptables firewall. These flags are not actually attacks, but rather more likely to be attempted by attackers to determine more information about your server using tools like nmap.

Some of the well-known bad flag combinations are SYN/FIN, which is used by a variety of network scanners to perform operating system detection.

I will start by adding a chain to hold the bad TCP flag rules.

 $ iptables -N BAD_FLAGS

Then we will redirect all TCP traffic to the bad TCP flags rules to be processed.

 $ iptables -A INPUT -p tcp -j BAD_FLAGS

When traffic is redirected to a user-defined chain by a rule, it will be processed against all the rules in the new chain and then return to the chain that redirected it to be processed by the next rule in the sequence. So all traffic comes to the BAD_FLAGS chain and then returns it to the INPUT chain.

 $ iptables -A BAD_FLAGS -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

Other variations on the SYN/FIN flag combination are used for similar purposes.

SYN/RST, SYN/FIN/PSH, SYN/FIN/RST, and SYN/FIN/RST/PSH

We can add rules for those combinations too:

Cool!!

Also, we can’t find in normal TCP/IP connections single FIN flag packets, so we can add a rule for that:

 $ iptables -A BAD_FLAGS -p tcp --tcp-flags FIN FIN -j DROP

We should also drop null packets. These are generally used for other forms of network probing used by scanning tools such as nmap

SYN Flooding

The attacker sends a packet with the SYN flag. The receiving host replies with a packet with the SYN/ACK flags. The attacker is not sending an ACK to complete the handshake and that leaves a fully open connection till the connection reaches timeout.

The attacker sends SYN flags and as a result, the receiving host would have many opened connections.

We can use the limit module of iptables firewall to reduce the risk of this sort of attack.

 $ iptables -A INPUT -p tcp -m limit --limit 10/second -j LOG

This command logs the tcp packets and limits the logging to ten entries per second.

With the same concept, we can limit the number of incoming SYN packets.

 $ iptables -A INPUT -i eth0 -p tcp --syn -m limit --limit 10/second -jACCEPT

Here we used the special TCP option –syn, which matches all packets with the ACK and RST bits cleared and the SYN flag set. This is the same as –tcp-flags SYN,RST,ACK SYN.

We have limited the number of incoming SYN packets to ten per second. On a busy system, this can cause bottlenecking so this value depends on your network and performance.

If this will throttle your network you can use SYN cookies.

Go into the  /etc/sysctl.conf   file and add this line:

 net.ipv4.tcp_syncookies = 1

Then save and reload:

 $ sysctl -p

Drop INVALID State Packets

The INVALID state is not associated with any known connection. This means any incoming packets in the INVALID state are not from connections on the host and should be dropped. For example:

 $ iptables -A INPUT -m state --state INVALID -j DROP

This rule will cover all incoming packets on all interfaces, and log and drop them.

Drop Fragmented Packets

Packet fragments occur when a packet is too large to be sent in one piece. The packet is broken up into fragments that are then reassembled on the receiving host.

The -f flag tells iptables firewall to select all fragments. So if you are not using iptables as a router, you can drop fragmented packets.

 $ iptables -A INPUT -f -j DROP

Save iptables Rules

All the rules we discussed will be lost if you reboot your server, so how can you save them?

You can save all of your rules using iptables-save command if you are using CentOS or Red Hat.

 $ iptables-save

You can save specific table like filter table only:

 $ iptables-save -t filter

Also, you can use iptables-restore to restore rules that were saved.

